/**
 * 编写一个算法来判断一个数 n 是不是快乐数
 * 「快乐数」 定义为：
 * 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
 * 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
 * 如果这个过程 结果为 1，那么这个数就是快乐数。
 * @param {number} n
 * @return {boolean}
 */

/**
 * 对于一个数通过平方和计算下一个数可能有以下三种情况
 * 1. 最终会到 1
 * 2. 最终会进入循环
 * 3. 值会越来越大，最后接近无限循环
 *
 * 针对第三种情况，现在进行分析
 *
 * 位数     最值值              下一个值
 * 1        9                   81
 * 2        99                  162
 * 3        999                 243
 * 4        9999                324
 * 13       9999999999999       1053
 *
 * 由上面可以看出对于 3 位数的数字，它不可能大于 243。
 * 这意味着它要么被困在 243 以下的循环内，要么跌到 1。
 * 4 位或 4 位以上的数字在每一步都会丢失一位，最会都降到三位数。
 * 所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，
 * 然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以排除第三种情况。
 *
 * 由上分析对于一个数通过平方和计算下一个数只可能有两种情况，要么是到达1，要么是进入循环
 *
 * @param {*} n
 */

/**
 * 快慢指针法
 * 我们虚拟一个链表，链表中的起始结点就是起始数字，后面的每一个节点都是前一个数字通过求平方和计算出的下一个值
 * 根据上面的分析我们可以知道 这个链表的要么就是一个环，要么最后一个节点就是 1
 * 这里使用快慢指针，快指针每次走两步，慢指针每次走一步，存在两种情况
 * 1. 快指针最先到达1
 * 2. 快指针跟慢指针重合
 *
 * 如果重合说明不是快乐数
 * 如果快指针指向1说明是快乐数
 *
 * @param {*} n
 */
var isHappy = function (n) {
	let slow = n;
	let fast = getNext(n);
	while (fast !== 1 && fast !== slow) {
		fast = getNext(getNext(fast));
		slow = getNext(slow);
	}
	return fast === 1;
};

function getNext(n) {
	let total = 0;
	while (n > 0) {
		let d = n % 10;
		total = total + d * d;
		n = Math.floor(n / 10);
	}
	return total;
}
